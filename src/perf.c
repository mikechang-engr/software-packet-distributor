/*
 * software-packet-distributor
 * SPDX-License-Identifier: BSD-3-Clause
 * Copyright (c) 2026 Mike Chang
 * Author: Mike Chang <mikechang.engr@gmail.com>
 */
#include "perf.h"
#include "globals.h"
#include "flow.h"
#include "core_distributor.h"
static inline bool greedy_enabled_impl(void){ const char *s=getenv("GREEDY"); if(!s) return true; return strcasecmp(s,"on")==0; }
bool greedy_enabled(void){ return greedy_enabled_impl(); }
static void ensure_dir(const char *path){ struct stat st; if (stat(path,&st)==0) return; (void)mkdir(path,0755); }
static FILE* open_csv(const char *path){ ensure_dir("/var/log/software-packet-distributor"); FILE *f=fopen(path,"a"); if(!f) return NULL; fseek(f,0,SEEK_END); long sz=ftell(f); if(sz<=0){ fputs("epoch,worker,rx_kpps,tx_kpps,drops,flows,fat_hits,fat_misses,fat_evictions", f); fputc('\n', f); fflush(f);} return f; }
unsigned greedy_reshaper_tick(const double *rx_vals, unsigned max_moves){ if(!greedy_enabled()) return 0u; unsigned hot=0,cold=0; double hot_v=rx_vals[0], cold_v=rx_vals[0]; for(unsigned wi=1; wi<NB_WORKERS; wi++){ if(rx_vals[wi]>hot_v){ hot_v=rx_vals[wi]; hot=wi; } if(rx_vals[wi]<cold_v){ cold_v=rx_vals[wi]; cold=wi; } } if(hot==cold) return 0u; unsigned moves=0; unsigned start=(unsigned)(0xC0FFEE11u & RETA_MASK); for(unsigned i=0;i<RETA_SZ && moves<max_moves;i++){ unsigned idx=(start+i) & RETA_MASK; if(g_reta[idx]==hot){ g_reta[idx]=(uint8_t)cold; moves++; } } return moves; }
int perf_main(void *arg){ (void)arg; puts("[perf] started"); const uint64_t hz=rte_get_tsc_hz(); uint64_t last_1s=rte_get_tsc_cycles(); uint64_t rx1[16]={0}, tx1[16]={0}, d1[16]={0}; uint64_t gen_tx1=0, gen_dp1=0, dist_rx1=0, dist_tx1=0, dist_dp1=0; uint64_t fat_hit1=0, fat_mis1=0, fat_evc1=0; unsigned seconds_seen=0; FILE *csv=open_csv("/var/log/software-packet-distributor/worker_stats_v105.csv"); while(!g_quit){ rte_delay_us_block(100000); uint64_t now=rte_get_tsc_cycles(); uint64_t delta=now-last_1s; if(delta<hz) continue; unsigned ticks=(unsigned)(delta/hz); double sec_1s=(double)ticks; last_1s += (uint64_t)ticks*hz; for(unsigned t=0;t<ticks;++t){ unsigned cur=seconds_seen+t+1u; unsigned sec_idx=(cur-1u)&7u; unsigned cycle_idx=(cur-1u)/8u; mutate_flows_chunk(sec_idx, cycle_idx);} seconds_seen+=ticks; time_t epoch=time(NULL); double wrx_sum=0,wtx_sum=0, wdp_sum=0; double rx_vals[16]; for(unsigned wi=0; wi<NB_WORKERS; wi++){ uint64_t rx_d=g_worker_rx[wi]-rx1[wi]; rx1[wi]=g_worker_rx[wi]; uint64_t tx_d=g_worker_tx[wi]-tx1[wi]; tx1[wi]=g_worker_tx[wi]; uint64_t dp_d=g_worker_drop[wi]-d1[wi]; d1[wi]=g_worker_drop[wi]; double rx_kpps=(sec_1s>0? (double)rx_d/sec_1s:0)/1e3; double tx_kpps=(sec_1s>0? (double)tx_d/sec_1s:0)/1e3; double dp_kpps=(sec_1s>0? (double)dp_d/sec_1s:0)/1e3; wrx_sum+=rx_kpps; wtx_sum+=tx_kpps; wdp_sum+=dp_kpps; rx_vals[wi]=rx_kpps; PERF_LOG("[perf] w%02u rx=%.2f Kpps tx=%.2f Kpps drop=%.2f Kpps flows=%u", WORKERS[wi], rx_kpps, tx_kpps, dp_kpps, (unsigned)g_flow_count_shadow[wi]); if(csv){ fprintf(csv, "%ld,%u,%.3f,%.3f,%.3f,%u,%llu,%llu,%llu", (long)epoch, WORKERS[wi], rx_kpps, tx_kpps, dp_kpps, (unsigned)g_flow_count_shadow[wi], (unsigned long long)(g_fat_hits - fat_hit1), (unsigned long long)(g_fat_misses - fat_mis1), (unsigned long long)(g_fat_evictions - fat_evc1)); fputc('\n', csv);} } uint64_t gtx_d=g_gen_tx-gen_tx1; gen_tx1=g_gen_tx; uint64_t gdp_d=g_gen_drop-gen_dp1; gen_dp1=g_gen_drop; uint64_t drx_d=g_dist_rx-dist_rx1; dist_rx1=g_dist_rx; uint64_t dtx_d=g_dist_tx-dist_tx1; dist_tx1=g_dist_tx; uint64_t ddp_d=g_dist_drop-dist_dp1; dist_dp1=g_dist_drop; double gen_tx_mpps=(sec_1s>0? (double)gtx_d/sec_1s:0)/1e6; double gen_dp_mpps=(sec_1s>0? (double)gdp_d/sec_1s:0)/1e6; double dist_rx_mpps=(sec_1s>0? (double)drx_d/sec_1s:0)/1e6; double dist_tx_mpps=(sec_1s>0? (double)dtx_d/sec_1s:0)/1e6; double dist_dp_mpps=(sec_1s>0? (double)ddp_d/sec_1s:0)/1e6; PERF_LOG("[perf] gen tx=%.2f Mpps drop=%.2f Mpps", gen_tx_mpps, gen_dp_mpps); PERF_LOG("[perf] dist rx=%.2f Mpps tx=%.2f Mpps drop=%.2f Mpps", dist_rx_mpps, dist_tx_mpps, dist_dp_mpps); double mean=wrx_sum/(double)NB_WORKERS; double var=0.0; for(unsigned wi=0; wi<NB_WORKERS; wi++){ double d=rx_vals[wi]-mean; var+=d*d; } var/=(double)NB_WORKERS; double sd=sqrt(var); PERF_LOG("[perf] workers rx stddev=%.2f Kpps", sd); double fmean=0.0; for(unsigned wi=0; wi<NB_WORKERS; wi++) fmean+=(double)g_flow_count_shadow[wi]; fmean/=(double)NB_WORKERS; double fvar=0.0; for(unsigned wi=0; wi<NB_WORKERS; wi++){ double fd=(double)g_flow_count_shadow[wi]-fmean; fvar+=fd*fd; } fvar/=(double)NB_WORKERS; double fsd=sqrt(fvar); PERF_LOG("[perf] workers flows stddev=%.2f", fsd); uint64_t fat_hit_d=g_fat_hits-fat_hit1; fat_hit1=g_fat_hits; uint64_t fat_mis_d=g_fat_misses-fat_mis1; fat_mis1=g_fat_misses; uint64_t fat_evc_d=g_fat_evictions-fat_evc1; fat_evc1=g_fat_evictions; double hits_M=(double)fat_hit_d/1e6; double mis_M=(double)fat_mis_d/1e6; double evc_M=(double)fat_evc_d/1e6; PERF_LOG("[perf] FAT hits=%.2fM misses=%.2fM evictions=%.2fM", hits_M, mis_M, evc_M); g_epoch += ticks; for(unsigned wi=0; wi<NB_WORKERS; wi++){ g_flow_count_shadow[wi]=g_flow_count[wi]; g_flow_count[wi]=0; } unsigned moves=greedy_enabled()? greedy_reshaper_tick(rx_vals, 8u):0u; printf("[reta] greedy moves=%u", moves); putchar('\n'); if(csv){ fflush(csv);} } if(csv) fclose(csv); return 0; }

/*
 * software-packet-distributor
 * SPDX-License-Identifier: BSD-3-Clause
 * Copyright (c) 2026 Mike Chang
 * Author: Mike Chang <mikechang.engr@gmail.com>
 */
#include "core_generator.h"
#include "globals.h"
#include "flow.h"
static inline double get_target_pps_from_env_impl(void){ const char *s_mpps=getenv("TARGET_MPPS"); const char *s_gbps=getenv("TARGET_GBPS"); if(s_mpps && s_mpps[0]){ char *end=NULL; double mpps=strtod(s_mpps,&end); if(end!=s_mpps && mpps>0.0) return mpps*1e6; } if(s_gbps && s_gbps[0]){ char *end=NULL; double gbps=strtod(s_gbps,&end); if(end!=s_gbps && gbps>0.0) return (gbps*1e9)/(WIRE_BYTES*8.0); } return (2.5*1e9)/(WIRE_BYTES*8.0);} 
double get_target_pps_from_env(void){ return get_target_pps_from_env_impl(); }
int gen_main(void *arg){ (void)arg; puts("[generator] started"); struct rte_mbuf *pkts[BURST]; const uint64_t hz=rte_get_tsc_hz(); const double target_pps=get_target_pps_from_env(); double bursts_per_sec=target_pps/(double)BURST; if(bursts_per_sec<1.0) bursts_per_sec=1.0; uint64_t cycles_per_burst=(uint64_t)((double)hz / bursts_per_sec); if(!cycles_per_burst) cycles_per_burst=1; uint64_t next_deadline=rte_get_tsc_cycles(); bool ramp=true; uint64_t ramp_cycles=(uint64_t)(0.25*(double)hz); while(!g_quit){ uint64_t now=rte_get_tsc_cycles(); if(now<next_deadline){ while(rte_get_tsc_cycles()<next_deadline){ if(g_quit) break; rte_pause(); } } next_deadline+=cycles_per_burst; unsigned this_burst = ramp ? (BURST/2) : BURST; unsigned idx=0; if(rte_pktmbuf_alloc_bulk(g_mpool, pkts, this_burst) == 0){ idx=this_burst; } else { for(; idx<this_burst; idx++){ struct rte_mbuf *m=rte_pktmbuf_alloc(g_mpool); if(!m){ break; } pkts[idx]=m; } } for(unsigned i=0;i<idx;i++){ uint32_t fidx=flow_wheel_next(); char *p_raw=(char*)rte_pktmbuf_append(pkts[i], WIRE_BYTES); if(!p_raw){ continue; } uint8_t *p=(uint8_t*)p_raw; const Flow *f=&g_flows[fidx]; const bool is_udp=(f->proto==PROTO_UDP); const uint8_t *tmpl = is_udp ? flow_template_udp() : flow_template_tcp(); unsigned hdrlen = is_udp ? (14+20+8) : (14+20+20); memcpy(p, tmpl, hdrlen); uint8_t *ip=p+14; uint8_t *l4=ip+20; ip[12]=f->src_ip[0]; ip[13]=f->src_ip[1]; ip[14]=f->src_ip[2]; ip[15]=f->src_ip[3]; ip[16]=f->dst_ip[0]; ip[17]=f->dst_ip[1]; ip[18]=f->dst_ip[2]; ip[19]=f->dst_ip[3]; uint16_t sport_be=rte_cpu_to_be_16(f->sport_base); uint16_t dport_be=rte_cpu_to_be_16(f->dport_base); l4[0]=(uint8_t)(sport_be>>8); l4[1]=(uint8_t)(sport_be); l4[2]=(uint8_t)(dport_be>>8); l4[3]=(uint8_t)(dport_be); } if(idx){ unsigned n=rte_ring_enqueue_burst(g_ingress_ring,(void**)pkts,idx,NULL); g_gen_tx+=n; if(n<idx){ g_gen_drop+=(idx-n); for(unsigned i=n;i<idx;i++){ rte_pktmbuf_free(pkts[i]); } } } if(ramp){ if(ramp_cycles>cycles_per_burst) ramp_cycles -= cycles_per_burst; else ramp=false; } } return 0; }

/*
 * software-packet-distributor
 * SPDX-License-Identifier: BSD-3-Clause
 * Copyright (c) 2026 Mike Chang
 * Author: Mike Chang <mikechang.engr@gmail.com>
 */
#include "flow.h"
static uint32_t lcg32(uint32_t *s){ *s = (*s)*1664525u + 1013904223u; return *s; }
static uint32_t prng_s=0xC0FFEE11u; static inline uint32_t prng(void){ return lcg32(&prng_s); }
Flow g_flows[NFLOWS]; static uint32_t g_wheel[WHEEL_SLOTS] __rte_cache_aligned; static uint32_t g_wheel_pos __rte_cache_aligned=0u;
static uint8_t l2_ip_udp_tmpl[14+20+8]; static uint8_t l2_ip_tcp_tmpl[14+20+20];
void build_header_templates(void){ memset(l2_ip_udp_tmpl,0,sizeof(l2_ip_udp_tmpl)); memset(l2_ip_tcp_tmpl,0,sizeof(l2_ip_tcp_tmpl)); l2_ip_udp_tmpl[12]=0x08; l2_ip_udp_tmpl[13]=0x00; l2_ip_tcp_tmpl[12]=0x08; l2_ip_tcp_tmpl[13]=0x00; l2_ip_udp_tmpl[14]=0x45; l2_ip_udp_tmpl[22]=64; l2_ip_tcp_tmpl[14]=0x45; l2_ip_tcp_tmpl[22]=64; l2_ip_udp_tmpl[23]=PROTO_UDP; l2_ip_tcp_tmpl[23]=PROTO_TCP; uint16_t iplen_udp=(uint16_t)(20+8+(WIRE_BYTES-(14+20+8))); uint16_t iplen_tcp=(uint16_t)(20+20+(WIRE_BYTES-(14+20+20))); l2_ip_udp_tmpl[16]=(uint8_t)(iplen_udp>>8); l2_ip_udp_tmpl[17]=(uint8_t)(iplen_udp); l2_ip_tcp_tmpl[16]=(uint8_t)(iplen_tcp>>8); l2_ip_tcp_tmpl[17]=(uint8_t)(iplen_tcp); l2_ip_tcp_tmpl[34]=(5u<<4);} 
static inline bool elephants_enabled(void){ const char *s=getenv("ELEPHANTS"); if(!s) return true; return strcasecmp(s,"on")==0; }
void build_flows_and_wheel(void){ for(unsigned i=0;i<NFLOWS;++i){ Flow *f=&g_flows[i]; uint32_t seed=0xC001CAFEu ^ i; f->src_ip[0]=192; f->src_ip[1]=168; f->src_ip[2]=(uint8_t)(lcg32(&seed)&0xFF); f->src_ip[3]=(uint8_t)(lcg32(&seed)&0xFF); f->dst_ip[0]=10; f->dst_ip[1]=0; f->dst_ip[2]=(uint8_t)(lcg32(&seed)&0xFF); f->dst_ip[3]=(uint8_t)(lcg32(&seed)&0xFF); f->sport_base=(uint16_t)((10000u+i)&0xFFFFu); f->dport_base=(uint16_t)((20000u+i)&0xFFFFu); f->proto=(i%2u)?PROTO_TCP:PROTO_UDP; } unsigned pos=0; if(elephants_enabled()){ unsigned eid[ELEPHANT_FLOWS]={NFLOWS-3u,NFLOWS-2u,NFLOWS-1u}; g_flows[eid[0]].proto=PROTO_UDP; g_flows[eid[1]].proto=PROTO_TCP; g_flows[eid[2]].proto=PROTO_TCP; unsigned ele_slots=(unsigned)(WHEEL_SLOTS*0.10); if(ele_slots==0u) ele_slots=1u; for(unsigned e=0;e<ELEPHANT_FLOWS;++e) for(unsigned k=0;k<ele_slots && pos<WHEEL_SLOTS;++k) g_wheel[pos++]=eid[e]; } for(unsigned i=0;i<NFLOWS && pos<WHEEL_SLOTS;++i){ g_wheel[pos++]=i; } for(unsigned i=0; pos<WHEEL_SLOTS; ++i){ g_wheel[pos++]=(i%NFLOWS);} for(int i=(int)WHEEL_SLOTS-1;i>0;--i){ int j=(int)(prng()% (uint32_t)(i+1)); uint32_t t=g_wheel[i]; g_wheel[i]=g_wheel[j]; g_wheel[j]=t; }}
void reshuffle_wheel(void){ for(int i=(int)WHEEL_SLOTS-1;i>0;--i){ int j=(int)(prng()% (uint32_t)(i+1)); uint32_t t=g_wheel[i]; g_wheel[i]=g_wheel[j]; g_wheel[j]=t; } }
void mutate_flows_chunk(unsigned sec_idx, unsigned cycle_idx){ unsigned start=sec_idx*128u; unsigned end=start+128u; static const uint8_t ip_inc2[4]={37,73,109,181}; static const uint8_t ip_inc3[4]={41,79,127,193}; static const uint8_t ip_incD2[4]={55,95,139,203}; static const uint8_t ip_incD3[4]={61,103,149,211}; static const uint16_t sport_inc[4]={131,197,263,331}; static const uint16_t dport_inc[4]={149,211,277,353}; uint8_t s2=ip_inc2[cycle_idx & 3u]; uint8_t s3=ip_inc3[cycle_idx & 3u]; uint8_t d2=ip_incD2[cycle_idx & 3u]; uint8_t d3=ip_incD3[cycle_idx & 3u]; uint16_t si=sport_inc[cycle_idx & 3u]; uint16_t di=dport_inc[cycle_idx & 3u]; for(unsigned i=start;i<end;i++){ Flow *f=&g_flows[i]; f->src_ip[2]=(uint8_t)(f->src_ip[2]+s2); f->src_ip[3]=(uint8_t)(f->src_ip[3]+s3); f->dst_ip[2]=(uint8_t)(f->dst_ip[2]+d2); f->dst_ip[3]=(uint8_t)(f->dst_ip[3]+d3); f->sport_base=(uint16_t)(f->sport_base+si); f->dport_base=(uint16_t)(f->dport_base+di); if(((i-start+cycle_idx)&3u)==0u){ f->proto=(f->proto==PROTO_UDP)?PROTO_TCP:PROTO_UDP; } } reshuffle_wheel(); }
uint32_t flow_wheel_next(void){ uint32_t v=g_wheel[g_wheel_pos]; g_wheel_pos=(g_wheel_pos+1)&(WHEEL_SLOTS-1); return v; }
const uint8_t* flow_template_udp(void){ return l2_ip_udp_tmpl; }
const uint8_t* flow_template_tcp(void){ return l2_ip_tcp_tmpl; }
